<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>運命の六属性診断 — 完全版</title>
  <meta name="description" content="占い師用 六属性診断 PWA（完全版）" />
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header class="topbar">
    <div class="wrap">
      <h1>運命の六属性診断（完全版）</h1>
      <div class="actions">
        <button id="btnMode">来客画面へ</button>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section id="screen-top" class="card">
      <h2>診断スタート</h2>
      <div class="row">
        <label>来訪者名（任意）<input id="inputName" placeholder="非表示/管理用" /></label>
        <label>生年月日<input id="inputDOB" type="date" /></label>
      </div>
      <div class="row">
        <label>性別
          <select id="inputSex"><option value="X">指定なし</option><option value="F">女性</option><option value="M">男性</option></select>
        </label>
        <label>家族構造
          <select id="inputFamily">
            <option value="single">単身</option>
            <option value="parent_child">親子</option>
            <option value="couple">夫婦</option>
            <option value="extended">大家族</option>
          </select>
        </label>
      </div>

      <div class="row">
        <label>手相の型
          <select id="inputPalm">
            <option value="masuke">マスカケ</option>
            <option value="support">支援型</option>
            <option value="dialog">対話型</option>
            <option value="late">晩成型</option>
            <option value="free">自由線</option>
            <option value="leader">統率型</option>
          </select>
        </label>
        <label>相手がいる場合は相手の生年月日（任意）<input id="inputPartnerDOB" type="date" /></label>
      </div>

      <div style="height:8px"></div>
      <button id="btnRun" class="primary">診断を実行（占い師操作）</button>
    </section>

    <section id="screen-admin" class="card hidden">
      <h2>占い師用 詳細診断</h2>
      <div id="adminResult" class="adminResult"></div>
      <div class="row">
        <button id="btnExport">診断結果をCSVで保存</button>
        <button id="btnClear">履歴クリア</button>
      </div>
    </section>

    <section id="screen-guest" class="card hidden guestCard">
      <h2>来客向け 要約表示</h2>
      <div id="guestResult" class="guestResult"></div>
      <div style="height:8px"></div>
      <div class="small">※詳細は占い師と相談ください</div>
    </section>

    <section id="screen-compat" class="card hidden">
      <h2>相性診断（要相手情報）</h2>
      <div id="compatResult" class="compatResult"></div>
    </section>

    <section id="screen-history" class="card">
      <h2>最近の診断（ローカル）</h2>
      <div id="historyList"></div>
    </section>
  </main>

  <footer class="footer">
    v1.0 • PWA 完全版 • オフライン対応
  </footer>

<script>
/* ---------------------------
  完全版ロジック（整合性重視）
  - 固定プロファイルは data/fixed_profiles.json を参照（後述）
  - 公式命数表が data/meisu_table.json にある場合、最優先で使う
  - ない場合は deterministic fallback を使う（改善可能）
----------------------------*/

const ATTRS = ["木","火","土","金","水","風"];
const STAR_MAP = [
  {name:"導星座",range:[1,5],metal:"金"},
  {name:"導星座",range:[6,10],metal:"銀"},
  {name:"精霊座",range:[11,15],metal:"金"},
  {name:"精霊座",range:[16,20],metal:"銀"},
  {name:"天命座",range:[21,25],metal:"金"},
  {name:"天命座",range:[26,30],metal:"銀"},
  {name:"時空座",range:[31,35],metal:"金"},
  {name:"時空座",range:[36,40],metal:"銀"},
  {name:"変容座",range:[41,45],metal:"金"},
  {name:"変容座",range:[46,50],metal:"銀"},
  {name:"叡智座",range:[51,55],metal:"金"},
  {name:"叡智座",range:[56,60],metal:"銀"}
];

// キャッシュ変数
let MEISU_TABLE = null;
let FIXED_PROFILES = null;
let COMP_MATRIX = null;

// 補助：外部 data ファイルを読み込む
async function loadDataFiles(){
  // fixed_profiles.json
  try{
    const r1 = await fetch('/data/fixed_profiles.json', {cache:'no-store'});
    if(r1.ok) FIXED_PROFILES = await r1.json();
    else FIXED_PROFILES = {};
  }catch(e){ FIXED_PROFILES = {}; }
  // compatibility matrix
  try{
    const r2 = await fetch('/data/compatibility_matrix.json', {cache:'no-store'});
    if(r2.ok) COMP_MATRIX = await r2.json();
    else COMP_MATRIX = {};
  }catch(e){ COMP_MATRIX = {}; }
  // meisu table (optional)
  try{
    const r3 = await fetch('/data/meisu_table.json', {cache:'no-store'});
    if(r3.ok) MEISU_TABLE = await r3.json();
    else MEISU_TABLE = null;
  }catch(e){ MEISU_TABLE = null; }
  console.info('Data loaded:', {fixedCount: Object.keys(FIXED_PROFILES||{}).length, compKeys: COMP_MATRIX?Object.keys(COMP_MATRIX).length:0, meisuLoaded: !!MEISU_TABLE});
}

// fallback命数計算（決定的）
function fallbackCalcMei(dob){
  const d = new Date(dob);
  if(isNaN(d)) return null;
  const y = d.getFullYear(), m = d.getMonth()+1, day = d.getDate();
  const ys = String(y).split('').reduce((a,b)=>a+Number(b),0);
  let s = ys + m + day;
  s = ((s - 1) % 60) + 1;
  return s;
}
function getMei(dob){
  if(!dob) return null;
  if(FIXED_PROFILES && FIXED_PROFILES[dob] && FIXED_PROFILES[dob].meisu) return FIXED_PROFILES[dob].meisu;
  if(MEISU_TABLE && MEISU_TABLE[dob]) return MEISU_TABLE[dob];
  return fallbackCalcMei(dob);
}
function getGuardianByMei(mei){
  for(const s of STAR_MAP){
    const [a,b] = s.range;
    if(mei >= a && mei <= b) return {name:s.name, metal:s.metal};
  }
  const idx = Math.floor(((mei-1)/5)) % STAR_MAP.length;
  return {name:STAR_MAP[idx].name, metal:STAR_MAP[idx].metal};
}
function attributeFromMei(mei){
  return ATTRS[(mei-1) % ATTRS.length];
}
function actionTypeFromMei(mei){
  const map = ["自由","支援","統率","対話","晩成","叡智"];
  return map[(mei-1) % map.length];
}

/* 過去ストーリー生成（テンプレ） */
function makePastStory(mei, attr, palm, family){
  const lines = [];
  lines.push(`幼少期に「${attr}」の気質が出やすく、その特性が根付きました。`);
  if(palm === 'masuke') lines.push("幼少期から孤高の瞬間があり、それが今の芯になっています。");
  if(family === 'parent_child') lines.push("家庭内で早期に役割を学んだ影響が見られます。");
  lines.push("過去に小さな決断が現在へとつながっています。");
  return lines.join("\n");
}

/* 相性計算：属性一致 + 命数差 + 家族ブースト + compatibility matrix */
function compatibilityScore(meiA, attrA, meiB, attrB, relation){
  let score = 0;
  if(attrA === attrB) score += 3;
  const diff = Math.abs(meiA - meiB);
  if(diff <= 5) score += 2;
  else if(diff <= 10) score += 1;
  if(relation === 'parent_child') score += 1;
  // matrix override if exists
  const key = `${attrA}_${attrB}`;
  if(COMP_MATRIX && COMP_MATRIX[key] && typeof COMP_MATRIX[key].score === 'number'){
    score = Math.round(score * 0.5 + COMP_MATRIX[key].score * 0.5);
  }
  return score;
}

/* 表示フォーマッタ */
function formatAdmin(detail){
  return `
    <div><strong>名前：</strong>${detail.name||'—'}</div>
    <div><strong>命数：</strong>${detail.mei}</div>
    <div><strong>属性：</strong>${detail.attribute}</div>
    <div><strong>守護星座：</strong>${detail.star.name}（${detail.star.metal}）</div>
    <div><strong>手相：</strong>${detail.palmLabel}</div>
    <div><strong>行動タイプ：</strong>${detail.action}</div>
    <hr/>
    <pre>${detail.story}</pre>
  `;
}
function formatGuest(detail){
  return `
    <div class="guestHead">あなたの属性は <strong>${detail.attribute}</strong></div>
    <div>核心：${detail.short}</div>
    <div>運のポイント：小さな変化を大切に</div>
  `;
}

/* UI helpers */
const el = id => document.getElementById(id);
function show(id){ document.querySelectorAll('main .card').forEach(c=>c.classList.add('hidden')); el(id).classList.remove('hidden'); }
function saveHistory(obj){
  const arr = JSON.parse(localStorage.getItem('sa_logs')||'[]');
  arr.unshift(obj);
  localStorage.setItem('sa_logs', JSON.stringify(arr.slice(0,200)));
  refreshHistory();
}
function refreshHistory(){
  const list = JSON.parse(localStorage.getItem('sa_logs')||'[]');
  const container = el('historyList');
  if(!list.length){ container.innerHTML = '<div class="small">履歴はありません</div>'; return; }
  container.innerHTML = list.map(it=>`<div class="histCard"><div><strong>${it.name||'非表示'}</strong> ${it.mei} / ${it.attribute} <span class="small">${new Date(it.timestamp).toLocaleString()}</span></div></div>`).join('');
}

/* Main run */
async function mainRun(){
  await loadDataFiles();
  // wire UI after data loaded
  el('btnRun').addEventListener('click', ()=>{
    const name = el('inputName').value.trim();
    const dob = el('inputDOB').value;
    const sex = el('inputSex').value;
    const family = el('inputFamily').value;
    const palm = el('inputPalm').value;
    if(!dob){ alert('生年月日を入力してください'); return; }
    // check FIXED_PROFILES
    let detail = null;
    if(FIXED_PROFILES && FIXED_PROFILES[dob]){
      const p = FIXED_PROFILES[dob];
      detail = {
        name: p.name, dob: p.birthday, sex, family, palm: p.palm,
        mei: p.meisu, attribute: p.attribute, star: p.guardian, action: p.behavior,
        palmLabel: p.palm === 'late' ? '晩成型' : p.palm,
        story: makePastStory(p.meisu, p.attribute, p.palm, family),
        short: `${p.attribute}の傾向が出ます。`,
        timestamp: new Date().toISOString()
      };
    } else {
      const mei = getMei(dob);
      const star = getGuardianByMei(mei);
      const attr = attributeFromMei(mei);
      const action = actionTypeFromMei(mei);
      detail = {
        name, dob, sex, family, palm, mei, attribute: attr, star, action,
        palmLabel: (palm === 'late' ? '晩成型' : palm),
        story: makePastStory(mei, attr, palm, family),
        short:`${attr}の傾向が強いタイプです。`,
        timestamp: new Date().toISOString()
      };
    }

    // Admin & guest view
    el('adminResult').innerHTML = formatAdmin(detail);
    el('guestResult').innerHTML = formatGuest(detail);

    // Compatibility
    const partnerDOB = el('inputPartnerDOB').value;
    if(partnerDOB){
      const pmei = getMei(partnerDOB);
      const pattr = attributeFromMei(pmei);
      const score = compatibilityScore(detail.mei, detail.attribute, pmei, pattr, family);
      el('compatResult').innerHTML = `<div>相性スコア: <strong>${score}</strong></div><div>相手属性: ${pattr}</div>`;
      show('screen-compat');
    } else {
      show('screen-admin');
    }

    saveHistory(detail);
  });

  // other UI actions
  el('btnExport').addEventListener('click', ()=>{
    const arr = JSON.parse(localStorage.getItem('sa_logs')||'[]');
    if(!arr.length){ alert('履歴がありません'); return; }
    const csv = arr.map(r=>[r.timestamp,r.name,r.dob,r.mei,r.attribute,r.palm].join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'diagnosis_history.csv';
    a.click();
  });
  el('btnClear').addEventListener('click', ()=>{
    if(confirm('履歴をクリアしますか？')){ localStorage.removeItem('sa_logs'); refreshHistory(); alert('クリアしました'); }
  });
  let guestMode = false;
  el('btnMode').addEventListener('click', ()=>{
    guestMode = !guestMode;
    if(guestMode){
      el('btnMode').innerText = '占い師画面へ';
      show('screen-guest');
    } else {
      el('btnMode').innerText = '来客画面へ';
      show('screen-admin');
    }
  });

  refreshHistory();
  show('screen-top');

  if('serviceWorker' in navigator){
    navigator.serviceWorker.register('./sw.js').catch(()=>{ console.warn('sw reg fail'); });
  }
}
mainRun();

/* ========== 整合性テストハーネス（ブラウザ console から実行） ========== */
async function runIntegrityTests(opts = {randomSamples:200, verbose:false}){
  await loadDataFiles();
  const report = {fixed:[], random:[], issues:[]};
  // fixed profiles
  const fixedKeys = FIXED_PROFILES ? Object.keys(FIXED_PROFILES) : [];
  for(const dob of fixedKeys){
    const p = FIXED_PROFILES[dob];
    const mei = getMei(dob);
    const star = getGuardianByMei(mei);
    const attr = attributeFromMei(mei);
    const action = actionTypeFromMei(mei);
    const okMei = (mei === p.meisu);
    const okStar = (star.name === p.guardian.constellation && star.metal === p.guardian.metal);
    const rec = {id:p.id,dob,expected:p,calc:{mei,star,attr,action},okMei,okStar};
    report.fixed.push(rec);
    if(!okMei || !okStar) report.issues.push({type:'fixed_mismatch',rec});
  }
  // random samples
  const samples = opts.randomSamples || 200;
  for(let i=0;i<samples;i++){
    const start = new Date('1940-01-01').getTime();
    const end = new Date('2032-12-31').getTime();
    const t = new Date(start + Math.floor(Math.random()*(end-start)));
    const dob = t.toISOString().slice(0,10);
    const mei = getMei(dob);
    const star = getGuardianByMei(mei);
    const attr = attributeFromMei(mei);
    const issues = [];
    if(!(mei>=1 && mei<=60)) issues.push('mei_out_of_range');
    if(!star || !star.name) issues.push('no_star');
    if(!ATTRS.includes(attr)) issues.push('attr_unknown');
    report.random.push({dob,mei,star,attr,issues});
    if(issues.length) report.issues.push({type:'random_issue',dob,issues});
  }
  // summary print
  console.group('Integrity Test Report');
  console.log('Fixed profiles tested:', report.fixed.length);
  report.fixed.forEach(r=>{
    const ok = r.okMei && r.okStar;
    if(ok) console.log('OK',r.id, r.dob, 'mei', r.calc.mei, 'star', r.calc.star.name, r.calc.star.metal);
    else console.warn('MISMATCH', r.id, r.dob, 'expected', r.expected, 'calc', r.calc);
  });
  console.log('Random samples:', report.random.length);
  if(report.issues.length===0) console.log('No issues detected — basic integrity OK.');
  else {
    console.warn('Issues detected:', report.issues.length);
    console.table(report.issues.slice(0,40));
  }
  console.groupEnd();
  return report;
}
</script>
</body>
</html>
